{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///postling.js","webpack:///webpack/bootstrap 70364af61f676f03c925","webpack:///./src/index.js","webpack:///./src/postling.js","webpack:///./src/utilities.js","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/module.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","Postling","undefined","_postling","_postling2","polyfill","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_utilities","REQUEST","RESPONSE","defaultConfig","window","parent","origin","document","referrer","internals","__setMethods__","names","_this","methods","reduce","name","_len","args","Array","_key","sendMessage","getId","create","__getMethods__","_this2","setMethods","then","keys","customConfig","_this3","onMessage","_ref","data","indexOf","_ret","_JSON$parse","JSON","parse","replace","type","payload","v","pending","error","result","console","method","test","bind","Promise","resolve","apply","catch","tagName","_parseUrl","parseUrl","getAttribute","protocol","host","contentWindow","config","addEventListener","removeEventListener","_this4","forEach","_this5","reject","_config","response","postMessage","stringify","url","link","createElement","setAttribute","hostname","port","pathname","search","hash","Math","random","toString","substr","__WEBPACK_AMD_DEFINE_RESULT__","process","global","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","node","createTextNode","observe","characterData","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","lib$es6$promise$asap$$useSetTimeout","setTimeout","lib$es6$promise$asap$$len","callback","lib$es6$promise$asap$$queue","arg","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","e","lib$es6$promise$then$$then","onFulfillment","onRejection","child","lib$es6$promise$$internal$$noop","lib$es6$promise$$internal$$PROMISE_ID","lib$es6$promise$$internal$$makePromise","state","_state","lib$es6$promise$$internal$$invokeCallback","_result","lib$es6$promise$$internal$$subscribe","lib$es6$promise$promise$resolve$$resolve","object","promise","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$selfFulfillment","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","lib$es6$promise$$internal$$FULFILLED","lib$es6$promise$$internal$$REJECTED","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","lib$es6$promise$then$$default","lib$es6$promise$promise$resolve$$default","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","subscribers","settled","detail","lib$es6$promise$$internal$$ErrorObject","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$$internal$$nextId","lib$es6$promise$$internal$$id","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","lib$es6$promise$enumerator$$Enumerator","input","_instanceConstructor","_input","_remaining","_enumerate","lib$es6$promise$enumerator$$validationError","Error","lib$es6$promise$polyfill$$polyfill","local","self","Function","P","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","substring","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$reject$$default","all","race","_setScheduler","_setAsap","_asap","_eachEntry","entry","_settledAt","_willSettleAt","enumerator","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","noop","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths","children"],"mappings":"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","file":"postling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Postling\"] = factory();\n\telse\n\t\troot[\"Postling\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Postling\"] = factory();\n\telse\n\t\troot[\"Postling\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = exports.Postling = undefined;\n\t\n\tvar _postling = __webpack_require__(1);\n\t\n\tvar _postling2 = _interopRequireDefault(_postling);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * # Index\n\t *\n\t *\n\t */\n\t\n\t__webpack_require__(3).polyfill();\n\t\n\texports.Postling = _postling2.default;\n\texports.default = _postling2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * # Postling\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * RPC interface to invoke messages inside an iframe.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _utilities = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar REQUEST = 'REQUEST';\n\tvar RESPONSE = 'RESPONSE';\n\t\n\tvar defaultConfig = {\n\t  // connect\n\t  source: window,\n\t  target: window.parent,\n\t  origin: document.referrer.length ? document.referrer : '*'\n\t};\n\t\n\tvar internals = {\n\t  /**\n\t   * Creates proxy functions which call the original in the iframe.\n\t   *\n\t   * @param {Array.<string>} names - list of available method names\n\t   */\n\t\n\t  __setMethods__: function __setMethods__(names) {\n\t    var _this = this;\n\t\n\t    var methods = names.reduce(function (methods, name) {\n\t      methods[name] = function () {\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t          args[_key] = arguments[_key];\n\t        }\n\t\n\t        return _this.sendMessage(REQUEST, (0, _utilities.getId)(), { name: name, args: args });\n\t      };\n\t      return methods;\n\t    }, Object.create(null));\n\t    this.methods = methods;\n\t  },\n\t\n\t  /**\n\t   * Invoke an update to retrieve available method names.\n\t   *\n\t   * @return {Promise} - list of method names\n\t   */\n\t  __getMethods__: function __getMethods__() {\n\t    var _this2 = this;\n\t\n\t    return this.setMethods(this.methods).then(function () {\n\t      return Object.keys(_this2.methods);\n\t    });\n\t  }\n\t};\n\t\n\tvar Postling = function () {\n\t  /**\n\t   * Define options of the instance\n\t   *\n\t   * @param  {HTMLElement|Object} customConfig - options of the instance\n\t   */\n\t\n\t  function Postling(customConfig) {\n\t    var _this3 = this;\n\t\n\t    _classCallCheck(this, Postling);\n\t\n\t    this.onMessage = function (_ref) {\n\t      var data = _ref.data;\n\t\n\t      if (typeof data === 'string' && data.indexOf('postling:') === 0) {\n\t        var _ret = function () {\n\t          var _JSON$parse = JSON.parse(data.replace('postling:', ''));\n\t\n\t          var type = _JSON$parse.type;\n\t          var id = _JSON$parse.id;\n\t          var payload = _JSON$parse.payload;\n\t\n\t\n\t          if (type === RESPONSE) {\n\t            return {\n\t              v: _this3.pending[id](payload.error, payload.result)\n\t            };\n\t          }\n\t\n\t          var name = payload.name;\n\t          var args = payload.args;\n\t\n\t\n\t          if (!name) {\n\t            return {\n\t              v: console.error('Invalid call - method name required!')\n\t            };\n\t          }\n\t\n\t          var method = /^__.*__$/.test(name) ? internals[name].bind(_this3) : _this3.methods[name];\n\t\n\t          if (!method) {\n\t            return {\n\t              v: console.error('Invalid method call: \"' + name + '\" !')\n\t            };\n\t          }\n\t\n\t          Promise.resolve(method.apply(null, args)).then(function (result) {\n\t            return _this3.sendMessage(RESPONSE, id, { result: result });\n\t          }).catch(function (error) {\n\t            return _this3.sendMessage(RESPONSE, id, { error: _extends({}, error) });\n\t          });\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      }\n\t    };\n\t\n\t    if (customConfig && customConfig.tagName === 'IFRAME') {\n\t      var _parseUrl = (0, _utilities.parseUrl)(customConfig.getAttribute('src'));\n\t\n\t      var protocol = _parseUrl.protocol;\n\t      var host = _parseUrl.host;\n\t\n\t      customConfig = {\n\t        target: customConfig.contentWindow,\n\t        origin: protocol + '//' + host\n\t      };\n\t    }\n\t\n\t    var config = _extends({}, defaultConfig);\n\t\n\t    if (customConfig) {\n\t      Object.assign(config, customConfig);\n\t    }\n\t\n\t    this.config = config;\n\t\n\t    this.pending = Object.create(null);\n\t    this.methods = Object.create(null);\n\t\n\t    config.source.addEventListener('message', this.onMessage);\n\t    // use global handler module is imported --> no racing condidation problme\n\t  }\n\t\n\t  /**\n\t   * Remove the event handler of the instance.\n\t   */\n\t\n\t\n\t  _createClass(Postling, [{\n\t    key: 'close',\n\t    value: function close() {\n\t      var source = this.config.source;\n\t\n\t      source.removeEventListener('message', this.onMessage);\n\t    }\n\t\n\t    /**\n\t     * Invoke handler to set and remove methods.\n\t     */\n\t\n\t  }, {\n\t    key: 'setMethods',\n\t    value: function setMethods(methods) {\n\t      var _this4 = this;\n\t\n\t      this.methods = _extends({}, this.methods, methods);\n\t      Object.keys(this.methods).forEach(function (name) {\n\t        if (!_this4.methods[name]) {\n\t          delete _this4.methods.name;\n\t        }\n\t      });\n\t      return this.sendMessage(REQUEST, (0, _utilities.getId)(), {\n\t        name: '__setMethods__',\n\t        args: [Object.keys(this.methods)]\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Invoke remote handler to retrieve the available methods.\n\t     */\n\t\n\t  }, {\n\t    key: 'getMethods',\n\t    value: function getMethods() {\n\t      return this.sendMessage(REQUEST, (0, _utilities.getId)(), {\n\t        name: '__getMethods__'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create an action which will be send over the connection.\n\t     *\n\t     * @param  {string}  type    - marker to specify outgoing and incoming message\n\t     * @param  {string}  id      - id to match the response\n\t     * @param  {*}       payload - data to send\n\t     * @return {Promise}         - response of the call\n\t     */\n\t\n\t  }, {\n\t    key: 'sendMessage',\n\t    value: function sendMessage(type, id, payload) {\n\t      var _this5 = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        var _config = _this5.config;\n\t        var target = _config.target;\n\t        var origin = _config.origin;\n\t\n\t        if (type === REQUEST) {\n\t          _this5.pending[id] = function (error, response) {\n\t            delete _this5.pending[id];\n\t            if (error) {\n\t              return reject(error);\n\t            }\n\t            resolve(response);\n\t          };\n\t        }\n\t        target.postMessage('postling:' + JSON.stringify({ type: type, id: id, payload: payload }), origin);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Event handler for postmessages.\n\t     *\n\t     * @param {Object} message - contains the payload data of the postmessage\n\t     */\n\t\n\t  }]);\n\t\n\t  return Postling;\n\t}();\n\t\n\texports.default = Postling;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.parseUrl = parseUrl;\n\texports.getId = getId;\n\t/**\n\t * # Utilities\n\t *\n\t *\n\t */\n\t\n\t/**\n\t * Simple URL parsing.\n\t *\n\t * @param  {string} url - URL to parse\n\t * @return {Object}     - property map\n\t */\n\tfunction parseUrl(url) {\n\t  var link = document.createElement('a');\n\t  link.setAttribute('href', url);\n\t  return {\n\t    protocol: link.protocol,\n\t    hostname: link.hostname,\n\t    port: link.port,\n\t    pathname: link.pathname,\n\t    search: link.search,\n\t    hash: link.hash,\n\t    host: link.host\n\t  };\n\t}\n\t\n\t/**\n\t * TODO: check if 'https://github.com/broofa/node-uuid' is required\n\t *\n\t * @return {[type]} [description]\n\t */\n\tfunction getId() {\n\t  return Math.random().toString(36).substr(2, 10);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.2.1\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(7);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n\t      var parent = this;\n\t\n\t      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {\n\t        lib$es6$promise$$internal$$makePromise(child);\n\t      }\n\t\n\t      var state = parent._state;\n\t\n\t      if (state) {\n\t        var callback = arguments[state - 1];\n\t        lib$es6$promise$asap$$asap(function(){\n\t          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);\n\t        });\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t      }\n\t\n\t      return child;\n\t    }\n\t    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n\t      if (maybeThenable.constructor === promise.constructor &&\n\t          then === lib$es6$promise$then$$default &&\n\t          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$id = 0;\n\t    function lib$es6$promise$$internal$$nextId() {\n\t      return lib$es6$promise$$internal$$id++;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$makePromise(promise) {\n\t      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;\n\t      promise._state = undefined;\n\t      promise._result = undefined;\n\t      promise._subscribers = [];\n\t    }\n\t\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        return new Constructor(function(resolve, reject) {\n\t          reject(new TypeError('You must pass an array to race.'));\n\t        });\n\t      } else {\n\t        return new Constructor(function(resolve, reject) {\n\t          var length = entries.length;\n\t          for (var i = 0; i < length; i++) {\n\t            Constructor.resolve(entries[i]).then(resolve, reject);\n\t          }\n\t        });\n\t      }\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();\n\t      this._result = this._state = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n\t        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: lib$es6$promise$then$$default,\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      this._instanceConstructor = Constructor;\n\t      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {\n\t        lib$es6$promise$$internal$$makePromise(this.promise);\n\t      }\n\t\n\t      if (lib$es6$promise$utils$$isArray(input)) {\n\t        this._input     = input;\n\t        this.length     = input.length;\n\t        this._remaining = input.length;\n\t\n\t        this._result = new Array(this.length);\n\t\n\t        if (this.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t        } else {\n\t          this.length = this.length || 0;\n\t          this._enumerate();\n\t          if (this._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$validationError() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var length  = this.length;\n\t      var input   = this._input;\n\t\n\t      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        this._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var c = this._instanceConstructor;\n\t      var resolve = c.resolve;\n\t\n\t      if (resolve === lib$es6$promise$promise$resolve$$default) {\n\t        var then = lib$es6$promise$$internal$$getThen(entry);\n\t\n\t        if (then === lib$es6$promise$then$$default &&\n\t            entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          this._settledAt(entry._state, i, entry._result);\n\t        } else if (typeof then !== 'function') {\n\t          this._remaining--;\n\t          this._result[i] = entry;\n\t        } else if (c === lib$es6$promise$promise$$default) {\n\t          var promise = new c(lib$es6$promise$$internal$$noop);\n\t          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n\t          this._willSettleAt(promise, i);\n\t        } else {\n\t          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n\t        }\n\t      } else {\n\t        this._willSettleAt(resolve(entry), i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var promise = this.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        this._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          this._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (this._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, this._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(5)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }()), __webpack_require__(6)(module)))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** postling.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 70364af61f676f03c925\n **/","/**\n * # Index\n *\n *\n */\n\nrequire('es6-promise').polyfill()\n\nexport Postling from './postling'\n\nexport default from './postling'\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * # Postling\n *\n * RPC interface to invoke messages inside an iframe.\n */\n\nimport { parseUrl, getId } from './utilities'\n\nconst REQUEST = 'REQUEST'\nconst RESPONSE = 'RESPONSE'\n\nconst defaultConfig = {\n  // connect\n  source: window,\n  target: window.parent,\n  origin: document.referrer.length ? document.referrer : '*'\n}\n\nconst internals = {\n  /**\n   * Creates proxy functions which call the original in the iframe.\n   *\n   * @param {Array.<string>} names - list of available method names\n   */\n  __setMethods__ (names) {\n    const methods = names.reduce((methods, name) => {\n      methods[name] = (...args) => this.sendMessage(REQUEST, getId(), { name, args })\n      return methods\n    }, Object.create(null))\n    this.methods = methods\n  },\n  /**\n   * Invoke an update to retrieve available method names.\n   *\n   * @return {Promise} - list of method names\n   */\n  __getMethods__ () {\n    return this.setMethods(this.methods).then(() => Object.keys(this.methods))\n  }\n}\n\nexport default class Postling {\n  /**\n   * Define options of the instance\n   *\n   * @param  {HTMLElement|Object} customConfig - options of the instance\n   */\n  constructor (customConfig) {\n\n    if (customConfig && customConfig.tagName === 'IFRAME') {\n      const { protocol, host } = parseUrl(customConfig.getAttribute('src'))\n      customConfig = {\n        target: customConfig.contentWindow,\n        origin: `${protocol}//${host}`\n      }\n    }\n\n    const config = {...defaultConfig}\n\n    if (customConfig) {\n      Object.assign(config, customConfig)\n    }\n\n    this.config = config\n\n    this.pending = Object.create(null)\n    this.methods = Object.create(null)\n\n    config.source.addEventListener('message', this.onMessage)\n    // use global handler module is imported --> no racing condidation problme\n  }\n\n  /**\n   * Remove the event handler of the instance.\n   */\n  close () {\n    const { source } = this.config\n    source.removeEventListener('message', this.onMessage)\n  }\n\n  /**\n   * Invoke handler to set and remove methods.\n   */\n  setMethods (methods) {\n    this.methods = {...this.methods,...methods}\n    Object.keys(this.methods).forEach((name) => {\n      if (!this.methods[name]) {\n        delete this.methods.name\n      }\n    })\n    return this.sendMessage(REQUEST, getId(), {\n      name: '__setMethods__',\n      args: [Object.keys(this.methods)]\n    })\n  }\n\n  /**\n   * Invoke remote handler to retrieve the available methods.\n   */\n  getMethods () {\n    return this.sendMessage(REQUEST, getId(), {\n      name: '__getMethods__'\n    })\n  }\n\n  /**\n   * Create an action which will be send over the connection.\n   *\n   * @param  {string}  type    - marker to specify outgoing and incoming message\n   * @param  {string}  id      - id to match the response\n   * @param  {*}       payload - data to send\n   * @return {Promise}         - response of the call\n   */\n  sendMessage (type, id, payload) {\n    return new Promise((resolve, reject) => {\n      const { target, origin } = this.config\n      if (type === REQUEST) {\n        this.pending[id] = (error, response) => {\n          delete this.pending[id]\n          if (error) {\n            return reject(error)\n          }\n          resolve(response)\n        }\n      }\n      target.postMessage('postling:' + JSON.stringify({ type, id, payload }), origin)\n    })\n  }\n\n  /**\n   * Event handler for postmessages.\n   *\n   * @param {Object} message - contains the payload data of the postmessage\n   */\n  onMessage = ({ data }) => {\n    if (typeof data === 'string' && data.indexOf('postling:') === 0) {\n\n      const { type, id, payload } = JSON.parse(data.replace('postling:', ''))\n\n      if (type === RESPONSE) {\n        return this.pending[id](payload.error, payload.result)\n      }\n\n      const { name, args } = payload\n\n      if (!name) {\n        return console.error(`Invalid call - method name required!`)\n      }\n\n      const method = (/^__.*__$/.test(name)) ? internals[name].bind(this) : this.methods[name]\n\n      if (!method) {\n        return console.error(`Invalid method call: \"${name}\" !`)\n      }\n\n      Promise.resolve(method.apply(null, args))\n      .then((result) => this.sendMessage(RESPONSE, id, { result }))\n      .catch((error) => this.sendMessage(RESPONSE, id, { error: {...error} }))\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/postling.js\n **/","/**\n * # Utilities\n *\n *\n */\n\n/**\n * Simple URL parsing.\n *\n * @param  {string} url - URL to parse\n * @return {Object}     - property map\n */\nexport function parseUrl (url) {\n  var link = document.createElement('a')\n  link.setAttribute('href', url)\n  return {\n    protocol: link.protocol,\n    hostname: link.hostname,\n    port: link.port,\n    pathname: link.pathname,\n    search: link.search,\n    hash: link.hash,\n    host: link.host\n  }\n}\n\n/**\n * TODO: check if 'https://github.com/broofa/node-uuid' is required\n *\n * @return {[type]} [description]\n */\nexport function getId () {\n  return Math.random().toString(36).substr(2, 10)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utilities.js\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.2.1\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n      var parent = this;\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\n      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {\n        lib$es6$promise$$internal$$makePromise(child);\n      }\n\n      var state = parent._state;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function(){\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    }\n    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n      if (maybeThenable.constructor === promise.constructor &&\n          then === lib$es6$promise$then$$default &&\n          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    var lib$es6$promise$$internal$$id = 0;\n    function lib$es6$promise$$internal$$nextId() {\n      return lib$es6$promise$$internal$$id++;\n    }\n\n    function lib$es6$promise$$internal$$makePromise(promise) {\n      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;\n      promise._state = undefined;\n      promise._result = undefined;\n      promise._subscribers = [];\n    }\n\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        return new Constructor(function(resolve, reject) {\n          reject(new TypeError('You must pass an array to race.'));\n        });\n      } else {\n        return new Constructor(function(resolve, reject) {\n          var length = entries.length;\n          for (var i = 0; i < length; i++) {\n            Constructor.resolve(entries[i]).then(resolve, reject);\n          }\n        });\n      }\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();\n      this._result = this._state = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: lib$es6$promise$then$$default,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {\n        lib$es6$promise$$internal$$makePromise(this.promise);\n      }\n\n      if (lib$es6$promise$utils$$isArray(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._result = new Array(this.length);\n\n        if (this.length === 0) {\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());\n      }\n    }\n\n    function lib$es6$promise$enumerator$$validationError() {\n      return new Error('Array Methods must be provided an Array');\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var input   = this._input;\n\n      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      var resolve = c.resolve;\n\n      if (resolve === lib$es6$promise$promise$resolve$$default) {\n        var then = lib$es6$promise$$internal$$getThen(entry);\n\n        if (then === lib$es6$promise$then$$default &&\n            entry._state !== lib$es6$promise$$internal$$PENDING) {\n          this._settledAt(entry._state, i, entry._result);\n        } else if (typeof then !== 'function') {\n          this._remaining--;\n          this._result[i] = entry;\n        } else if (c === lib$es6$promise$promise$$default) {\n          var promise = new c(lib$es6$promise$$internal$$noop);\n          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n          this._willSettleAt(promise, i);\n        } else {\n          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n        }\n      } else {\n        this._willSettleAt(resolve(entry), i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        this._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = value;\n        }\n      }\n\n      if (this._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-promise/dist/es6-promise.js\n ** module id = 3\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}